// 基数排序是根据位数进行排序的一种算法

// 比如下面的过程
// 先根据第三位数字进行排序，然后第二位，最后第一个
/**
 * 255      120    120    120
 * 171      341    632    255
 * 632  =>  271 => 341 => 271
 * 715      632    745    341
 * 241      255    255    632
 * 120      745    271    745
*/

// 如何获取末尾数字？ 采用余数法， 1004 % 1000 4

// 如何采用空间换时间？ 桶思维
// 以第一次排序（即根据末位大小进行一次排序）作为分析
/**
 * 255      120   
 * 171      341
 * 632  =>  271
 * 715      632
 * 241      255
 * 120      745
*/
// 因为数字范围为 0 - 9 所以
// 桶 -> [0, 1,  2, 3, 4, 5, 6, 7, 8, 9]
//      120 341 632       255
//          271           745
// 这样， 6个数就分好了
// 怎么样保证输出？ 队列的方式，先进先出
// 比如以1结尾的[341,271], 是341先进，那就341先出
// 因此，得到 120 341 271 632 255 745
// 其他的以此类型

function radix_sort(A) {
  // 数组的最大值， 他的位数决定了需要循环多次次， 比如 1000， 就需要4次
  const max = Math.max(...A)
  // 弄一个桶，结构为二维数组 
  const buckets = Array.from({length: 10}, () => [])
  // 用于和max做比较，以结束循环
  let m = 1
  while(m < max) {
    A.forEach( number => {
      // 当 m = 1 时，就是用个位比较
      // 当 m = 2 时，就是用十位比较
      const digit = ~~( (number % (m * 10) ) / m)
      buckets[digit].push(number)
    })
    let j = 0;
    // 将数从桶中拿出
    buckets.forEach(bucket => {
      while(bucket.length > 0) {
        // 先进先出
        A[j++] = bucket.shift()
      }
    })
    m * 10
  }
}
