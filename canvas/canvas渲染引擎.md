平常的html css也是通过渲染引擎渲染出来的 

比如新版chrome的Blink, andriod的skia

quickjs(v8) + libuv + skia(基于浏览器之外的渲染js渲染引擎)

webkit是负责解析html css的引擎，将其渲染成可以被渲染的数据

cpu 串行排队执行，平常写的代码就是要交给cpu执行的 js代码

gpu 可以并行执行  webgl的着色器

canvas 渲染引擎： 

1、 拾取
2、分层  （频繁绘制的单独做一个图层）
3、局部绘制
4、 事件封装


canvas 绘图是基于路径， 绘制之后，路径就清空了

isPointInStroke 这个api可以达到拾取的效果，但是如果路径一开始没有保存的话

那么canvas会自动重新开启路径， 而重启路径则会遍历图中所有的点的集合进行判断，只是不会再次绘制而已，因此可能会造成性能的损耗

也因此，需要另外一种方案来做拾取

采用比较多的就是，分层，拾取的部分，放到上层去操作，操作完再绘制到下层去

// postMessage 消息传递采用的是 结构化克隆算法  shareArrayBuffer 用于共享内存

// WA (webAssambly )

// 借助gpu webgl计算大数据量


// webkit 将css 转换成 skia可识别的数据， skia渲染引擎，其实本质也是类似canvas的绘图

// 而且也是分很多层进行绘制， 


v8 是什么？ 可以执行js程序， 也可以说是一个软件，
v8 在什么地方运行？ 在线程运行， 因此需要进程提供空间

因此，平常大家说js是单线程的，但其实说法也不是太对， 

也因此， 浏览器在运行时，是会存在阻塞。 因为js在运行的时候，其实浏览器在运行v8线程， 那么gui线程就不能运行了。





  



