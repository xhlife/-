<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- 出处  https://juejin.cn/post/6844903982742110216 -->
  <!-- 
    虚拟列表: 其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。
   -->

   <!-- 
    由于只是对可视区域内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：
    infinite-list-container 为可视区域的容器
    infinite-list-phantom 为容器内的占位，高度为总列表高度，用于形成滚动条
    infinite-list 为列表项的渲染区域
    -->
    <div class="infinite-list-container">
      <div class="infinite-list-phantom"></div>
      <div class="infinite-list">
        <!-- item-1 -->
        <!-- ...... -->
        <!-- item-n -->
      </div>
    </div>

    <!-- 接着监听infinite-list-container的scroll事件，获取滚动位置scrollTop -->
    <!-- 
      假设：
      可视区域的高度固定: screenHeight
      列表每项高度固定: itemSize 
      列表数据: listData
      当前滚动位置: scrollTop
     -->
     <!-- 
      可推算：
      列表总高度：listHeight = listData.length * itemSize
      可显示的列表项数visibleCount = Math.ceil(screenHeight / itemSize)
      数据的起始索引startIndex = Math.floor(scrollTop / itemSize)
      数据的结束索引endIndex = startIndex + visibleCount
      列表显示数据为visibleData = listData.slice(startIndex,endIndex)

      偏移量startOffset = scrollTop - (scrollTop % itemSize);
      -->

      <!-- 
        当滚动后，由于渲染区域相对于可视区域已经发生了偏移，此时我需要获取一个偏移量startOffset，通过样式控制将渲染区域偏移至可视区域中。
       -->
</body>
</html>